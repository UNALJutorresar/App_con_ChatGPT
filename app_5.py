# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ufi6B5w94ClvNGe23tEoIIGoj2vp0K_e
"""

import streamlit as st
import numpy as np
import pygame
import os
os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = "hide"
from PIL import Image

class Ball:
    def __init__(self, x, y, radius, color, velocity_x=0, velocity_y=0):
        self.x = x
        self.y = y
        self.radius = radius
        self.color = color
        self.velocity_x = velocity_x
        self.velocity_y = velocity_y

    def update(self, dt, width, height, gravity=980):  # gravity in pixels/s^2
        # Update position
        self.x += self.velocity_x * dt
        self.y += self.velocity_y * dt

        # Apply gravity
        self.velocity_y += gravity * dt

        # Wall collisions with dampening
        dampening = 0.7
        if self.x - self.radius < 0:
            self.x = self.radius
            self.velocity_x = abs(self.velocity_x) * dampening
        elif self.x + self.radius > width:
            self.x = width - self.radius
            self.velocity_x = -abs(self.velocity_x) * dampening

        if self.y - self.radius < 0:
            self.y = self.radius
            self.velocity_y = abs(self.velocity_y) * dampening
        elif self.y + self.radius > height:
            self.y = height - self.radius
            self.velocity_y = -abs(self.velocity_y) * dampening

class BallPit:
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.balls = []
        self.surface = pygame.Surface((width, height))

    def add_ball(self, ball):
        self.balls.append(ball)

    def check_collisions(self):
        for i in range(len(self.balls)):
            for j in range(i + 1, len(self.balls)):
                ball1 = self.balls[i]
                ball2 = self.balls[j]

                dx = ball2.x - ball1.x
                dy = ball2.y - ball1.y
                distance = np.sqrt(dx**2 + dy**2)

                if distance < ball1.radius + ball2.radius:
                    # Collision detected - calculate new velocities
                    normal_x = dx / distance
                    normal_y = dy / distance

                    relative_velocity_x = ball1.velocity_x - ball2.velocity_x
                    relative_velocity_y = ball1.velocity_y - ball2.velocity_y

                    velocity_along_normal = (relative_velocity_x * normal_x +
                                          relative_velocity_y * normal_y)

                    # Elastic collision impulse
                    impulse = 2 * velocity_along_normal / 2  # Assuming equal masses

                    # Update velocities
                    ball1.velocity_x -= impulse * normal_x
                    ball1.velocity_y -= impulse * normal_y
                    ball2.velocity_x += impulse * normal_x
                    ball2.velocity_y += impulse * normal_y

                    # Separate balls to prevent sticking
                    overlap = (ball1.radius + ball2.radius - distance) / 2
                    ball1.x -= overlap * normal_x
                    ball1.y -= overlap * normal_y
                    ball2.x += overlap * normal_x
                    ball2.y += overlap * normal_y

    def update(self, dt):
        for ball in self.balls:
            ball.update(dt, self.width, self.height)
        self.check_collisions()

    def draw(self):
        self.surface.fill((255, 255, 255))
        for ball in self.balls:
            pygame.draw.circle(self.surface, ball.color,
                             (int(ball.x), int(ball.y)), ball.radius)

        # Convert Pygame surface to PIL Image
        string_image = pygame.image.tostring(self.surface, 'RGB')
        pil_image = Image.frombytes('RGB', self.surface.get_size(), string_image)

        return pil_image

def main():

    # App Title
    st.title("Ballpit Simulator")

    # App Authors
    st.write("App developed by Juan Camilo Torres Arboleda & Claude AI.")

    # Initialize Pygame
    pygame.init()

    # Simulation parameters
    WIDTH = 800
    HEIGHT = 600

    # Initialize step counter in session state
    if 'step' not in st.session_state:
        st.session_state.step = 0

    # Create ball pit
    if 'ball_pit' not in st.session_state:
        ball_pit = BallPit(WIDTH, HEIGHT)

        # Add initial balls
        for _ in range(20):
            x = np.random.randint(50, WIDTH-50)
            y = np.random.randint(50, HEIGHT-50)
            radius = np.random.randint(15, 30)
            color = (np.random.randint(0, 255),
                    np.random.randint(0, 255),
                    np.random.randint(0, 255))
            velocity_x = np.random.randint(-200, 200)
            velocity_y = np.random.randint(-200, 200)

            ball = Ball(x, y, radius, color, velocity_x, velocity_y)
            ball_pit.add_ball(ball)

        st.session_state.ball_pit = ball_pit

    # Create a placeholder for the simulation
    frame_placeholder = st.empty()

    # Add controls
    col1, col2, col3 = st.columns(3)

    with col1:
        gravity = st.slider("Gravity", min_value=0, max_value=2000,
                          value=980, step=100)

    with col2:
        dt = st.slider("Time Step (ms)", min_value=1, max_value=100,
                      value=16, step=1) / 1000.0

    with col3:
        add_ball = st.button("Add Ball")

    # Display current step
    st.write(f"Current Step: {st.session_state.step}")

    # Add step control buttons
    col1, col2, col3 = st.columns(3)
    with col1:
        if st.button("Step Forward"):
            st.session_state.step += 1
            st.session_state.ball_pit.update(dt)

    with col2:
        on = st.toggle("Continous Run")
        while on:
            st.session_state.step += 1
            st.session_state.ball_pit.update(dt)

    with col3:
        steps = st.number_input("Multi-step", min_value=1, max_value=100, value=10)
        if st.button(f"Forward {steps} steps"):
            for _ in range(steps):
                st.session_state.step += 1
                st.session_state.ball_pit.update(dt)


    if add_ball:
        x = np.random.randint(50, WIDTH-50)
        y = np.random.randint(50, HEIGHT-50)
        radius = np.random.randint(15, 30)
        color = (np.random.randint(0, 255),
                np.random.randint(0, 255),
                np.random.randint(0, 255))
        ball = Ball(x, y, radius, color, 0, 0)
        st.session_state.ball_pit.add_ball(ball)

    # Draw current frame
    frame = st.session_state.ball_pit.draw()
    frame_placeholder.image(frame, use_column_width=True)

if __name__ == "__main__":
    main()